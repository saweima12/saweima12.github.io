{"metadata":{"title":"用 AIOGram 建立機器人專案 — Telegram Bot 開發雜談（一）","tags":["bot","python","programing"],"excerpt":"廣告機器人一大堆、鬧群份子一個接一個？又或是想要做些聊天機器人小工具？透過 AIOGram 快速開發 Python Telegram Bot，用流程自動化解決所有麻煩事情。","created":"2022-07-23T00:00:00.000Z"},"content":"<p>午安旅人，這裡是一個月沒有更新文章的 Saweima。不知道旅人有沒有在 Telegram 公開群組遇到過惡意騷擾人士呢？時不時的開新帳號跑進群組貼一些會讓人感到噁心的圖片，踢完過一陣子又再次故技重施，猶如蟑螂一般，殺也殺不完。</p>\n<p>考量到管理員不可能時時刻刻都在、刪除圖片時管理員自身也不可避免的會受到精神攻擊，人工處理顯然不是一種好辦法。由於需求的急迫性，花了幾週時間研究及編寫機器人，在這邊記錄下自己用到的東西們。</p>\n<h2 id=\"aiogram\" class=\"heading-item\">AIOGram</h2><p>AIOGram 是 Telegram Bot API 的 Python 包裝器，用於將繁瑣的 HTTP API 呼叫流程包裝為程式物件並解析 API 的回傳資料，讓操作流程與程式語句一樣直觀。</p>\n<blockquote>\n<p><strong>AIOGram</strong> <br/>\nGithub: <a href=\"https://github.com/aiogram/aiogram\" target=\"_blank\" rel=\"noreferrer noopenner\">點我進入</a> <br/>\n官方文擋: <a href=\"https://docs.aiogram.dev/en/latest/\" target=\"_blank\" rel=\"noreferrer noopenner\">點我進入</a> <br/></p>\n</blockquote>\n<p>特性：</p>\n<ul>\n<li>使用 Python 3.7 以上版本。</li>\n<li>透過 asyncio 及 aiphttp 實作，支援 Asynchronous （異步/非同步）調用。</li>\n<li>內置 API 封包解析及定義型別，省去研究封包結構的時間。</li>\n</ul>\n<p>其他的 API 包裝器可參考 <a href=\"https://core.telegram.org/bots/samples\" target=\"_blank\" rel=\"noreferrer noopenner\"><strong>Telegram 的官方列表</strong></a></p>\n<h2 id=\"註冊-telegram-bot\" class=\"heading-item\">註冊 Telegram Bot</h2><p>在使用之前，必須先透過 Telegram Bot Father 註冊新的 bot 帳戶。</p>\n<img class=\"lightbox\" src=\"https://media.saweicore.com/blog/create-aiogram-project/register-tg-bot.jpg\" height=\"500\" />\n\n\n<ul>\n<li>加入有藍色勾勾（證明為官方帳號）的 BotFather</li>\n<li>輸入指令 <code>/newbot</code> 註冊新的 Bot</li>\n<li>第一次輸入 Bot 的名稱</li>\n<li>第二次輸入 Bot 的帳號</li>\n</ul>\n<p>以上流程都成功後就後會取得使用 API 的 TOKEN 如：<code>5292723007:AAE-APVbUkZgOZ6CVb4GM_KfV7CtE5dgLmw</code>，這段需要保存好，未來所有操作都會需要用到。</p>\n<h2 id=\"建立基本結構\" class=\"heading-item\">建立基本結構</h2><p>AIOGram 各 Module 負責的功能：</p>\n<ul>\n<li><code>Bot</code> class 將所有 Telegram Bot API 的指令包裝成 function 形式，主要負責傳送 request 給 Telegram 伺服器。</li>\n<li><code>Dispatcher</code> class 負責接收所有透過 Webhook 收到的訊息，並轉換為對應的 Object。</li>\n<li><code>types</code> module 底下包含所有型別及其相關的輔助 Function，如 Update、Message。</li>\n</ul>\n<p>運行的主要流程：\n-&gt; 接收 Telegram 的 Update 訊息\n-&gt; 傳入 Dispatcher 進行分類\n-&gt; Dispatcher 將分類後的訊息發送給註冊的 Handler \n-&gt; Handler 進行處理後回傳 HTTP Response 給 Telegram 伺服器（如果收到非 200 的 status code 會等待一定時間後重新傳送）</p>\n<p><strong>Update 資訊的取得方式有以下兩種：</strong></p>\n<h3 id=\"使用-polling\" class=\"heading-item\">使用 Polling</h3><pre><code class=\"language-py\"># 導入 Aiogram 包\nfrom aiogram import Bot\nfrom aiogram.types import Message, ContentTypes\nfrom aiogram.dispatcher import Dispatcher\nfrom aiogram.utils.executor import start_polling\n\n# 記錄 BOT_TOKEN 並且建立 Bot 物件\nBOT_TOKEN = &quot;5292723007:AAE-APVbUkZgOZ6CBGM_KfV7CtE5dgLmw&quot;\nbot = Bot(BOT_TOKEN)\n# 建立 Bot 的分發器（收到的 Data 會被傳入這裡\ndp = Dispatcher(bot)\n\n# Process start command\n@dp.message_handler(commands=[&#39;start&#39;])\nasync def on_start_command(message: Message):  \n    print(&quot;on start command&quot;)\n\n# Process all messages except start command\n@dp.message_handler(content_types=ContentTypes.ANY)\nasync def on_message(message: Message):\n    await message.reply(message.from_user.id)\n\nasync def on_startup(dispatcher: Dispatcher):\n    print(&quot;startup&quot;)\n\nasync def on_shutdown(dispatcher: Dispatcher):\n    print(&quot;shutdown&quot;)\n\n\nif __name__ == &quot;__main__&quot;:\n    start_polling(dp, on_startup=on_startup, on_shutdown=on_shutdown)\n</code></pre>\n<p>Polling 方式是透過一個迴圈，定期的呼叫 Telegram Bot API 的 getUpdate 方法取得新的訊息，並將其傳入 dispatcher 進行分發，直到被中斷為止。</p>\n<ul>\n<li><code>Bot</code> 類負責與 Bot API 溝通，包含 <strong>send_message</strong> 或 <strong>deleted_message</strong> 等主動操作的 method 。</li>\n<li><code>Dispatcher</code> 類負責<strong>接收 API 的 Update 訊息</strong>（不論是透過 Polling 還是 Webhook 接收的）依據特徵分發給各 message_handler 。</li>\n<li><code>Message</code> 類是<strong>透過 Dispatcher 分類過後的訊息物件</strong>，包含 message_id , chat_id, user_id 等關鍵的判斷訊息， AIOGram 也有在此基礎上實作許多輔助方法。</li>\n<li><code>dp.message_handler()</code> 可以<strong>將底下的 function 註冊為處理器</strong>，並且透過參數如: <strong>content_types</strong> 、<strong>commands</strong> 設定只接包含哪些特徵的訊息。</li>\n<li><code>start_polling</code> 用於執行<strong>輪詢抓取 Telegram 的訊息</strong>更新。</li>\n</ul>\n<h3 id=\"使用-webhook\" class=\"heading-item\">使用 Webhook</h3><pre><code class=\"language-py\">from aiogram import Bot\nfrom aiogram.types import Message, ContentTypes\nfrom aiogram.dispatcher import Dispatcher\nfrom aiogram.utils.executor import start_webhook\n\nBOT_TOKEN = &quot;5292723007:AAE-APVbUkZgOZ6CBGM_KfV7CtE5dgLmw&quot;\n\n# WEBHOOK SETTING\nWEBHOOK_DOMAIN = &quot;https://68dc-211-23-21-139.jp.ngrok.io&quot;\nWEBHOOK_PATH=&quot;/api&quot;\nWEBHOOK_URI=f&quot;{WEBHOOK_DOMAIN}{WEBHOOK_PATH}&quot;\n\n# WEBHOST SETTING\nWEB_HOST = &quot;0.0.0.0&quot; # or ip\nWEB_HOST_PORT = 8000\n\nbot = Bot(BOT_TOKEN)\ndp = Dispatcher(bot)\n\n# Process start command\n@dp.message_handler(commands=[&#39;start&#39;])\nasync def on_start_command():  \n    print(&quot;on start command&quot;)\n\n# Process all messages except start command\n@dp.message_handler(content_types=ContentTypes.ANY)\nasync def on_message(message: Message):\n    await message.reply(message.from_user.id)\n\n\nasync def on_startup(dispatcher: Dispatcher):\n    print(&quot;startup&quot;)\n    await bot.set_webhook(WEBHOOK_URI)\n\n\nasync def on_shutdown(dispatcher: Dispatcher):\n    print(&quot;shutdown&quot;)\n    await bot.delete_webhook()\n\n\nif __name__ == &quot;__main__&quot;:\n    start_webhook(dispatcher=dp, \n                webhook_path=WEBHOOK_PATH,\n                on_startup=on_startup,\n                on_shutdown=on_shutdown,\n                skip_updates=True,\n                host=WEB_HOST, \n                port=WEB_HOST_PORT)\n</code></pre>\n<p>Webhook 方式是在啟動時通知 Telegram 伺服器將新訊息傳輸至對應的 URL，透過 HTTP 接口來接收資訊。</p>\n<p>大多數結構與使用 Polling 時相同，因此這邊僅列舉差異的地方。</p>\n<ul>\n<li><code>bot.set_webook</code> 用於通知 Telegram 伺服器，將訊息傳輸到註冊的 URL。</li>\n<li><code>bot.delete_webhook</code> 用於關閉時通知 Telegram 伺服器停止輸送訊息至註冊的 URL</li>\n<li><code>start_webhook</code> 用於啟動 AIOGram 內建的小型 HTTP Server 監聽 webhook_path 參數指定的路徑。host、port 用於配置啟動的 host 與 port。</li>\n</ul>\n<blockquote>\n<ul>\n<li>較為推薦使用 Webhook 方式接收 Update 訊息，可以節省頻繁發送封包的流量及不斷輪詢計算損耗的電腦資源。</li>\n<li>不過要以此作為接收訊息方式，需要一個支援 HTTPS 的網域。因此還是依據手邊的資源決定。</li>\n</ul>\n</blockquote>\n<h2 id=\"如何在本地端進行測試？\" class=\"heading-item\">如何在本地端進行測試？</h2><p>如果使用 Polling 接收資訊的話倒還好，但使用 Webhook 的話，最先遇上的問題就是怎麼進行測試，總不能每次都先發布到遠端伺服器，又或是先改成 Polling 要發布時才改回來，很沒有效率，這時候就可以考慮使用反向代理工具。</p>\n<h3 id=\"ngrok\" class=\"heading-item\">Ngrok</h3><blockquote>\n<p><strong>Ngrok</strong> <br/>\n<a href=\"https://ngrok.com/\" target=\"_blank\" rel=\"noreferrer noopenner\">https://ngrok.com/</a></p>\n</blockquote>\n<p>Ngrok 是一款有提供免費方案的反向代理工具，並且支援 HTTPS 轉發，可以用於本地端的 Webhook 測試，完全滿足這次的需求，使用前需要先在官網註冊帳號取得 AUTH_TOKEN 並下載對應作業系統的檔案。輸入以下指令設定 AUTH_TOKEN</p>\n<pre><code class=\"language-sh\">ngrok config add-authtoken {AUTH_TOKEN}\n</code></pre>\n<p>設定完成後，再來只需要輸入以下指令即可將自己的 PORT 8000 綁定到 ngrok 提供的 domain 上。</p>\n<pre><code class=\"language-sh\">ngrok http 8000\n</code></pre>\n<p>成功後如下：</p>\n<img class=\"lightbox\" src=\"https://media.saweicore.com/blog/create-aiogram-project/ngrok-test.jpg\" height=\"195\"/>\n\n<p>圖中的 <code>https://928c-211-23-21-139.ngrok.io</code> 就是透過 ngrok 取得的 URL DOMAIN，它就相當於連接到本機的 port 8000 。</p>\n<p>當一切就緒，就可以試著與機器人對話，如果按照上面的範例，旅人應該會收到一串神奇的數字，那便是自己的 user_id 。</p>\n<h2 id=\"如果不使用包裝器的話？\" class=\"heading-item\">如果不使用包裝器的話？</h2><p>若不使用包裝器，在 Telegram Bot API 中所有的操作，不論是 <strong>[接收資訊]</strong> 還是 <strong>[發送訊息]</strong> 都是透過 HTTP API 來進行。結構如下：</p>\n<pre><code class=\"language-text\">https://api.telegram.org/bot{BOT_TOKEN}/{METHOD_NAME}\n</code></pre>\n<ul>\n<li><code>BOT_TOKEN</code> -&gt; 從 BotFather 取得的 Token String </li>\n<li><code>METHOD_NAME</code> -&gt; 對應的方法名稱，如：getMe、getUpdates</li>\n</ul>\n<p>支援 GET 與 POST 的操作，意味著對於簡單的訊息可以直接使用瀏覽器輸入 Url QueryParams。</p>\n<pre><code class=\"language-text\">https://api.telegram.org/bot{BOT_TOKEN}/{METHOD_NAME}?url={API_URL}\n</code></pre>\n<p>針對複雜的操作可以透過 POST 並夾帶於 Body 中。支援的 Content-Type：</p>\n<ul>\n<li><code>application/x-www-form-urlencoded</code></li>\n<li><code>application/json (except for uploading files)</code></li>\n<li><code>multipart/form-data (use to upload files)</code></li>\n</ul>\n<p>以 GetUpdates 為例，透過呼叫 API：\n<code>https://api.telegram.org/bot{BOT_TOKEN}/getUpdates</code></p>\n<p>最後獲得的 response：</p>\n<pre><code class=\"language-js\">{\n  &quot;ok&quot;:true,\n  &quot;result&quot;:[\n    {\n      &quot;update_id&quot;:136940592,\n      &quot;message&quot;:{\n        &quot;message_id&quot;:964,\n        &quot;from&quot;:{\n          &quot;id&quot;:549919258,\n          &quot;is_bot&quot;:false,\n          &quot;first_name&quot;:&quot;Ch.&quot;,\n          &quot;last_name&quot;:&quot;S&quot;,\n          &quot;username&quot;:&quot;Saweima&quot;\n        },\n        &quot;chat&quot;:{\n          &quot;id&quot;:-1001756617092,\n          &quot;title&quot;:&quot;T1 Group&quot;,\n          &quot;type&quot;:&quot;supergroup&quot;\n        },\n        &quot;date&quot;:1657095304,\n        &quot;text&quot;:&quot;test&quot;\n      }\n    }\n  ]\n}\n</code></pre>\n<p>在不使用包裝器的情況下，需要自己組合出對應的 API URL 呼叫，並且自己處理回傳的 message。 這些是包裝器主要節省的部份。</p>\n<h2 id=\"注意事項\" class=\"heading-item\">注意事項</h2><ul>\n<li>部份機器人的操作（如：刪除其他人訊息、設定權限...等）需要有對應的群組權限。</li>\n<li>非群組管理員的機器人，只在遇到自己登記過的指令才會收到相關訊息。</li>\n<li>若為群組管理員的機器人，會接收到該群組內的所有訊息。</li>\n<li>若一則訊息在 Telegram 伺服器發送給機器人之前被刪除，則機器人會收不到該則訊息。</li>\n<li>Telegram 超過 500 人的群組有可能收不到 Join Message。</li>\n<li>機器人之間會互相干擾，必須確保機器人產生的對話內容、接收的指令不會觸發其他機器人。</li>\n</ul>\n<h2 id=\"tldr\" class=\"heading-item\">TL;DR</h2><ul>\n<li>AIOGram 是 Telegram Bot API 的包裝器，用以簡化機器人開發流程。</li>\n<li>AIOGram 支援<strong>輪詢抓取更新 - Polling</strong> 及<strong>被動接收更新 - Webhook</strong>。</li>\n<li>推薦使用 Webhook 作為接收更新的方式，用以節省流量與運算資源。</li>\n<li>使用 Webhook 接收更新需要有支援 https 的 domain。</li>\n<li>可以透過 Ngrok 的反向代理，測試本機端的 Webhook 與 API 。</li>\n<li>若不使用包裝器，則需要自己組合出 HTTP URL 及自行處理訊息的解析。</li>\n</ul>\n","headings":[{"depth":2,"text":"AIOGram","id":"aiogram"},{"depth":2,"text":"註冊 Telegram Bot","id":"註冊-telegram-bot"},{"depth":2,"text":"建立基本結構","id":"建立基本結構"},{"depth":3,"text":"使用 Polling","id":"使用-polling"},{"depth":3,"text":"使用 Webhook","id":"使用-webhook"},{"depth":2,"text":"如何在本地端進行測試？","id":"如何在本地端進行測試？"},{"depth":3,"text":"Ngrok","id":"ngrok"},{"depth":2,"text":"如果不使用包裝器的話？","id":"如果不使用包裝器的話？"},{"depth":2,"text":"注意事項","id":"注意事項"},{"depth":2,"text":"TL;DR","id":"tldr"}]}
{"metadata":{"title":"Sanic - 輕量快速的 Python Web Framework","tags":["web","python","programing"],"excerpt":"一款支援非同步調用不阻塞執行緒、編寫風格簡潔不拖泥帶水、內置高效率伺服器方便部署的 Python 框架，適合用於快速開發中小型專案。","created":"2022-08-08T00:00:00.000Z"},"content":"<p>Sanic 是一款 Python 的 Web 框架，編寫風格繼承了老牌框架 Flask 的簡潔並在其之上添加 async / await 的非同步調用支援，外加內建快速高效的 HTTP Server，提供了開箱即用、快速開發、生產部署的解決方案。</p>\n<blockquote>\n<p><strong>Sanic</strong><br/>\n官方網站： <a href=\"https://sanic.dev/\" target=\"_blank\" rel=\"noreferrer noopenner\">點我進入</a><br/></p>\n</blockquote>\n<p><strong>安裝方式：</strong></p>\n<pre><code class=\"language-sh\">pip install sanic\n</code></pre>\n<h2 id=\"框架特性\" class=\"heading-item\">框架特性</h2><ul>\n<li>使用 Python 3.8 以上的版本（推薦直接使用 Python 3.10）</li>\n<li>支援 async / await 非同步特性（執行 IO 操作時不會阻塞）</li>\n<li>內建快速的 HTTP Server </li>\n<li>類 Flask 的簡潔架構，易於擴充與編寫。</li>\n</ul>\n<blockquote>\n<p>編寫這邊文章時使用的版本為 <strong>22.6.1</strong>，通常使用最新的版本即可。</p>\n</blockquote>\n<h2 id=\"建立基本結構\" class=\"heading-item\">建立基本結構</h2><p>啟動 Sanic  的方式有以下兩種：</p>\n<ul>\n<li>透過腳本運行 -&gt; 在編寫腳本中使用 <code>Sanic.run()</code> 運行。</li>\n<li>使用 CLI -&gt; 使用 <code>Sanic CLI</code> 將 application 作為 module 導入(<strong>推薦</strong>)</li>\n</ul>\n<h3 id=\"透過-apprun-運行\" class=\"heading-item\">透過 app.run() 運行</h3><p>在根目錄中建立 app.py ，並建立 Sanic instance，透過 app.run 運行伺服器。</p>\n<pre><code class=\"language-python\">from sanic import Sanic\n\n# create sanic app\napp = Sanic(__name__)\n\nif __name__ == &#39;__main__&#39;:\n        # 透過 app.run 運行\n    app.run(host=&quot;0.0.0.0&quot;, debug=True)\n</code></pre>\n<h3 id=\"透過-cli-運行推薦\" class=\"heading-item\">透過 CLI 運行(推薦)</h3><p> 建立以下資料夾結構，當資料夾內有 <code>__init__.py</code> 檔案時，該資料夾就會被 python 視為 pacakge。</p>\n<pre><code class=\"language-text\">/\n├─ sanicapp\n│   └─  __init__.py\n└─ run.sh\n</code></pre>\n<ul>\n<li><code>__init__.py</code>  中建立 Sanic Instance 。</li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic\n\n# create sanic app\napp = Sanic(__name__)\n\n# __name__ 可改為自定義 App 名稱\n</code></pre>\n<ul>\n<li>最後使用以下 shell 指令執行 sanic 伺服器。</li>\n</ul>\n<pre><code class=\"language-shell\">sanic sanicapp:app -H 0.0.0.0 -p 8080 -d\n</code></pre>\n<ul>\n<li><code>sanicapp</code>為 package 的名稱，<code>app</code> 為 instance 變量。</li>\n<li><code>-H</code> 用於指定 Host Address (預設為 127.0.0.1)</li>\n<li><code>-p</code> 用於指定 Port (預設為 8000)</li>\n<li><code>-d</code> 用於開啟 Debug 模式（會自動重載及看到更詳細的 log）</li>\n<li><code>-w</code> 用於指定要啟動幾個 worker </li>\n<li>可透過 <code>-h</code> 參數觀看詳細的說明</li>\n</ul>\n<p>使用 CLI 運行 Sanic 伺服器可以在運行環境配置上獲得更多的彈性。當需要改變 host 或是 debug mode 時，可以直接變更參數，不需要修改腳本的 app.run 的參數。</p>\n<h2 id=\"handler\" class=\"heading-item\">Handler</h2><p>Handler 是處理 Request 的基本單元，<strong>至少會收到一個 Reqeust 物件並 return 一個 HTTPResponse</strong> 。</p>\n<ul>\n<li>Request.headers -&gt;  取得夾帶在 request header 的資料。</li>\n<li>Request.args  or Request.query_args -&gt; 取得 URLQueryParams</li>\n<li>Request.body -&gt; 取得發出 POST Request 時夾帶在 body 欄位的內容。<ul>\n<li>取得的資料為純 bytes 需要轉譯。</li>\n</ul>\n</li>\n<li>Request.json -&gt; 當 content_type 為 &quot;application/json&quot; 時，會自動將 body 中的內容轉為 Python Dictionary</li>\n</ul>\n<pre><code class=\"language-python\">import asyncio\nimport asyncio\nimport time\nfrom sanic import Sanic, HTTPResponse, Request, response\n\napp = Sanic(__name__)\n\n@app.get(&quot;/typed&quot;)\ndef typed(request: Request) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(sync)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    time.sleep(1)\n    return response.text(&quot;Done&quot;)\n\n\n@app.get(&quot;/async_typed/&lt;tag&gt;&quot;)\nasync def async_typed(request: Request, tag: str) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(async)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    await asyncio.sleep(1)\n    return response.text(&quot;Done&quot;)\n</code></pre>\n<p>對應官方文檔： <a href=\"https://sanic.dev/en/guide/basics/handlers.html#a-word-about-async\" target=\"_blank\" rel=\"noreferrer noopenner\">https://sanic.dev/en/guide/basics/handlers.html#a-word-about-async</a></p>\n<blockquote>\n<p>實務上應該盡量使用 async / await 以避免執行緒阻塞，執行上會更有效率。</p>\n</blockquote>\n<h2 id=\"routing\" class=\"heading-item\">Routing</h2><p>Routing 用於將 Handler 註冊至對應的 URL，當伺服器接收到對應路由時，會將收到的資料轉換成 Request 並執行對應的 Handler。</p>\n<p>註冊 Routing 的方式有三種：</p>\n<ul>\n<li>透過 app.add_route() </li>\n<li>透過 @app.route / @app.get 等裝飾器</li>\n<li>Blueporint</li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic, HTTPResponse, Request, response\n\napp = Sanic(__name__)\n\ndef typed(request: Request) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(sync)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    return response.text(&quot;Done&quot;)\n\n# register route by decorator\n@app.get(&quot;/async_typed/&lt;tag&gt;&quot;)\nasync def async_typed(request: Request, tag: str) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(async)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    return response.text(&quot;Done&quot;)\n\n# register route by add_route()\napp.add_route(typed, &quot;/typed&quot;, methods=[&quot;GET&quot;])\n</code></pre>\n<p><code>@app.get()</code> 等裝飾器只是 <code>app.add_route()</code> 的封裝，用於增加可讀性。</p>\n<h3 id=\"blueprint\" class=\"heading-item\">Blueprint</h3><p>儘管能夠透過 <code>app.add_route()</code> 註冊路由，但這會導致所有 handler 必須依賴於 Sanic instance，當需要設置的路由數量增加時會很不方便，此時可採用 blueprint 方案。</p>\n<ul>\n<li><strong>view.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Blueprint, HTTPResponse, Request, response\n\nbp = Blueprint(&quot;peon&quot;)\n\ndef typed(request: Request) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(sync)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    return response.text(&quot;Done&quot;)\n\n# register route by decorator\n@bp.get(&quot;/async_typed/&lt;tag&gt;&quot;)\nasync def async_typed(request: Request, tag: str) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(async)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    return response.text(&quot;Done&quot;)\n\n# Blueprint 的 route 註冊方式與使用 app.add_route 相同。\nbp.add_route(typed, &quot;/typed&quot;, methods=[&quot;GET&quot;])\n</code></pre>\n<ul>\n<li><strong>app.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic, HTTPResponse, Request, response\nfrom .view import bp\n\napp = Sanic(__name__)\n\n# 使用 app.blueprint 將 blueprint instance 註冊進 app 路由。\napp.blueprint(bp)\n</code></pre>\n<p>使用 Blueprint 可以將 Route 與 Handle 與 Sanic instance 分離開來，達到關注點分離的效果。</p>\n<h2 id=\"app-registry\" class=\"heading-item\">App Registry</h2><p>當建立 Sanic instance 時，會將該 instance 寫入 Sanic 內部的註冊表中，可以透過 <code>Sanic.get_app()</code> 取得 app 的 instance。</p>\n<ul>\n<li><strong>app.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic\n\napp = Sanic(&quot;my_server&quot;)\n</code></pre>\n<ul>\n<li><strong>db.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic\n\napp = Sanic.get_app(&quot;my_server&quot;)\n</code></pre>\n<p>若建立的 instance 只有一個時，也可以不用填入 instance name，直接使用 <code>Sanic.get_app()</code> 就能取得 instance 。</p>\n<h2 id=\"app-context\" class=\"heading-item\">App Context</h2><p>App Context （中文翻譯稱作上下文）用於附加希望<strong>能夠重複使用的 instance</strong> ，像是與資料庫的連接 、定期運作的排程器等。</p>\n<ul>\n<li><strong>app.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic, HTTPResponse, Request, response\nfrom .view import bp\nfrom . import scheduler\n\napp = Sanic(__name__)\n\n# lifecycle hook - 在 server 運行之前將 instance 註冊進 context.\n@app.before_server_start\nasync def startup(app: Sanic):\n    scheduler.setup(app)\n\napp.blueprint(bp)\n</code></pre>\n<ul>\n<li><strong>scheduler.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Sanic\n\nfrom .struct import AppScheduler\n\nSERVICE_CODE = &quot;app_scheduler&quot;\n\ndef get() -&gt; AppScheduler:\n    app = Sanic.get_app()\n    # 使用 getattr 取得 app.ctx 中的 instance\n    return getattr(app.ctx, SERVICE_CODE)\n\ndef setup(app: Sanic) -&gt; AppScheduler:\n    app = Sanic.get_app()\n    scheduler = AppScheduler(app)\n    # 使用 setattr 將 instance 寫入 app.ctx\n    setattr(app.ctx, SERVICE_CODE, scheduler)\n    return scheduler\n</code></pre>\n<ul>\n<li><strong>view.py</strong></li>\n</ul>\n<pre><code class=\"language-python\">from sanic import Blueprint, HTTPResponse, Request, response\nfrom . import scheduler\n\nbp = Blueprint(&quot;peon&quot;)\ndef typed(request: Request) -&gt; HTTPResponse:\n    &quot;&quot;&quot;\n    get Done(sync)\n    \n    :param reuqest [sanic.Request]\n    &quot;&quot;&quot;\n    _scheudler = scheduler.get()\n    return response.text(&quot;Done&quot;)\n</code></pre>\n<p>範例中使用 <code>@app.before_server_start</code> 在運行之前將 AppScheduler 嵌入 app.ctx 內。 並在 handler 中過 <code>scheduler.get()</code> 將其從 app.ctx 中取出，藉此重複利用 instance。</p>\n<h2 id=\"listener-lifecycle\" class=\"heading-item\">Listener (LifeCycle)</h2><p>Sanic 包含 8 個 Hook：</p>\n<p><strong>只在 sanic app 建立/停止時執行一次:</strong></p>\n<ul>\n<li>main_process_start</li>\n<li>main_process_stop</li>\n</ul>\n<p><strong>每個 worker 都會執行一次</strong></p>\n<ul>\n<li>before_server_start</li>\n<li>after_server_start</li>\n<li>before_server_stop</li>\n<li>after_server_stop</li>\n</ul>\n<p><strong>當 auto_reload 被開啟時，每次 reload 就會執行一次</strong></p>\n<ul>\n<li>reload_process_start</li>\n<li>reload_process_stop</li>\n</ul>\n<pre><code class=\"language-python\">@app.reload_process_start\nasync def reload_start(*_):\n    print(&quot;&gt;&gt;&gt;&gt;&gt;&gt; reload_start &lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n\n\n@app.main_process_start\nasync def main_start(*_):\n    print(&quot;&gt;&gt;&gt;&gt;&gt;&gt; main_start &lt;&lt;&lt;&lt;&lt;&lt;&quot;)\n</code></pre>\n<ul>\n<li><code>main_process_start</code> 經常用於初始化僅能初始化一次的時候（設置遠端的 webhook)</li>\n<li><code>before_server_start</code> 及 <code>after_server_start</code> 常用於建立可重複使用的 instance 並且附加至 app.ctx 作為常駐 service 使用。</li>\n<li><code>before_server_stop</code> 用於關閉各 service 的連接並清除資料。</li>\n</ul>\n<h2 id=\"應用範例\" class=\"heading-item\">應用範例</h2><blockquote>\n<p><strong>Sanic Example</strong><br/>\nGithub: <a href=\"https://github.com/saweima12/sanic-example\" target=\"_blank\" rel=\"noreferrer noopenner\">點我進入</a></p>\n</blockquote>\n<h2 id=\"tldr\" class=\"heading-item\">TL;DR</h2><ul>\n<li>Sanic 是 Python 3.8 版本以上的輕量 Web 框架，支援 async / await 的非同步特性。</li>\n<li>推薦使用 Sanic CLI 運行 Server ，在環境配置上有更多的彈性。</li>\n<li>Handler 是處理 Request 的基本單元，會<strong>至少接收一個 Request 物件並返回 HttpResponse 物件</strong>。</li>\n<li>應該<strong>盡量使用 async / await</strong> 處理 handler 邏輯，避免執行緒阻塞、增加運作效率。</li>\n<li>Routing 用於<strong>將路由與 Handler 進行綁定</strong>，當 Server 接收到指定的路徑時，會將資料打包成 Request 送至對應的 Handler。</li>\n<li>App Context 用於<strong>存放希望重複使用的 instance</strong>，像是資料庫連接、排程器等。</li>\n</ul>\n","headings":[{"depth":2,"text":"框架特性","id":"框架特性"},{"depth":2,"text":"建立基本結構","id":"建立基本結構"},{"depth":3,"text":"透過 app.run() 運行","id":"透過-apprun-運行"},{"depth":3,"text":"透過 CLI 運行(推薦)","id":"透過-cli-運行推薦"},{"depth":2,"text":"Handler","id":"handler"},{"depth":2,"text":"Routing","id":"routing"},{"depth":3,"text":"Blueprint","id":"blueprint"},{"depth":2,"text":"App Registry","id":"app-registry"},{"depth":2,"text":"App Context","id":"app-context"},{"depth":2,"text":"Listener (LifeCycle)","id":"listener-lifecycle"},{"depth":2,"text":"應用範例","id":"應用範例"},{"depth":2,"text":"TL;DR","id":"tldr"}]}